
High Priority
===============

- TRANSACTIONS
- INSERT
- UPDATE
- Better WHERE class


Medium Priority
================
- DELETE (3 forms, see: http://dev.mysql.com/doc/refman/5.0/en/delete.html)
  - second form
  - third form
- We *need* 100 % coverage of all ways data can be modified under MySQL
- Integration with rails
  - Intercept/Override Mysql Adapter:
    - SELECT => #select
    - model declarations (to add to ActiveRecord::Base)
- Security: simple key value pairs of username, password,
  with all access to data.  Can we encrypt this over SSL
  (or another secure protocol) to get to the DRB process?
- DRb, so that multiple mongrels can all talk to the same cache
- Threading for the drb/data access
- Write all database access to a log


Low Priority:
===============

_ CREATE TABLE
- SELECT:
    - Joins
    - GROUP BY
    - LIMIT with offset
    - mysql procedures (for GROUP BY)
    - mysql modifiers  (i.e. DISTINCT)
- Joins
- errors in sql parsing 
  - SQLNotUnderstood (a parsing error)
  - NotImplementedErrors (for selects which aren't implemented)
- Treetop doesn't support case insensitive matching.  Need to provide
  a patch for this
- Reorganize expression class.  Conjunction & Disjunction should be
  Compound conditions.  
- REPL = read, eval, print loop.  Can we harness IRB?  Use #inspect
  to return rows, like mysql


Miscelaneous:
===============

- rake tasks:
    - building gem
    - github gem integration
- profiling reports on large tables
- when 0.1 release is done, publish gem to github & rubyforge
    

Unclassified:
===============

- Efficiency issues: Indexes ?
- should we give a dup of hashes out of the cache?  Does AR modify 
  the values inside the hash of #select?
- Database formats.  Is one big array per table really a good format?
  - Should Set be used instead of Array?
- Other database adapters?  SQLite?  Decouple design
- Option to disconnect from database entirely in tests.
  - if NotImplementedError, then we *should* use the real database!
- Could we make this lazy, as opposed to eager?
  - seems that we could, if we could figure out that certain queries
    are subsets of other queries.  For instance:
        SELECT * FROM users WHERE user_name = "scott"
        SELECT * FROM users WHERE user_name = "scott" AND first_name = "Scott"
   Or, that queries could be combined:
        SELECT * FROM users WHERE first_name = "Scott"
        SELECT * FROM users WHERE last_name = "Taylor"
        SELECT * FROM users WHERE first_name = "Scott" AND last_name = "Taylor"
- It sure would be nice to be able to limit how big in RAM these
  objects will get, i.e.:
  
  class MyClass < ActiveRecord::Base
    cache_model :limit_memory => 100.megabytes
  end
  
  We now have Object#object_size

- Split this project into two (or three) parts:
   - A parser
   - A gem
   - A rails plugin

- flog reports, spec reports.  take rake tasks from fixture replement
- optional syntax highlighting with the colored gem


Other Thoughts:
==================

- Plugable storage engine. Getting something working now is more important
  than building something great which works in 10 years.  Should also
  show what the priorities are (for instance, joins may be very important,
  but currently they are low on the priority list)
      
      - Pure Ruby, shared memory.  Thread/state based.  Concurrency issues,
        big time.  How to stay in sync with the database?
      - Use erlang.  How to use shared memory in erlang?  Something needs
        to persist the data in memory...
      - Use a prebuilt tool in erlang.  Mensia has an in memory database.
        Can it be lightweight and do everything we need it to do?
      - Use time based cache (like memcached), but only in certain places:
            cache(:ttl => 25.minutes) do
               User.find(:all, :conditions => {:my => :conditions})
            end

        This would replace the connection adapters select query,
        but only for that query (just as it works with cache_fu).  The first
        time the query is run, select * from users is cached.  No new query is
        run on the users table (assuming queries are wrapped in cache declarations)
        for another 25 minutes.  (How should multiple cache calls against the same table
        with different ttls work?).  The cache declaration would not need to exist inside
        a descendent of ActiveRecord::Base - it could just as easily come in a controller
        or presenter

        The declaration could also be made global for the whole model - although then
        it would loose much of it's flexibility.
   
  There's no reason all of these are options, just like mysql has different
  storage engines.

        

         
    